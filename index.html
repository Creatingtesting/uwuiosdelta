<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoonSec V3 Lua Deobfuscator</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8fafc;
            color: #1f2937;
        }
        h1 {
            text-align: center;
            font-size: 2.5rem;
            color: #1e40af;
            margin-bottom: 1rem;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            padding: 1rem;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .input-section, .output-section {
            display: flex;
            flex-direction: column;
        }
        label {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #374151;
        }
        textarea {
            width: 100%;
            height: 400px;
            padding: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            resize: vertical;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            background: #f9fafb;
            transition: border-color 0.2s;
        }
        textarea:focus {
            outline: none;
            border-color: #1e40af;
            box-shadow: 0 0 0 3px rgba(30, 64, 175, 0.1);
        }
        button {
            background: linear-gradient(to right, #1e40af, #3b82f6);
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            margin-top: 1rem;
            transition: transform 0.2s, background 0.2s;
        }
        button:hover:not(:disabled) {
            background: linear-gradient(to right, #1e3a8a, #2563eb);
            transform: translateY(-2px);
        }
        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        #output {
            width: 100%;
            min-height: 400px;
            padding: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: #f9fafb;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            overflow-y: auto;
        }
        .error {
            color: #dc2626;
            font-size: 0.9rem;
            margin-top: 0.5rem;
            font-weight: 500;
        }
        .info {
            color: #4b5563;
            font-size: 0.9rem;
            margin-top: 0.5rem;
            line-height: 1.5;
            text-align: center;
        }
        .progress {
            color: #1e40af;
            font-size: 0.9rem;
            margin-top: 0.5rem;
            display: none;
        }
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
            textarea, #output {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <h1>MoonSec V3 Lua Deobfuscator</h1>
    <p class="info">
        Paste your obfuscated MoonSec V3 Lua code below and click "Deobfuscate". This tool uses every known method (ASCII, base64, XOR, hex, VM emulation, etc.) to decode strings, constants, and logic. Complex scripts may require manual analysis or tools like Prometheus Deobfuscator.
    </p>
    <div class="container">
        <div class="input-section">
            <label for="input">Obfuscated MoonSec V3 Code:</label>
            <textarea id="input" placeholder="Paste your obfuscated MoonSec V3 Lua code here..."></textarea>
            <button id="deobfuscateBtn" onclick="deobfuscate()">Deobfuscate</button>
            <div id="progress" class="progress">Processing...</div>
        </div>
        <div class="output-section">
            <label for="output">Deobfuscated Code:</label>
            <div id="output">Deobfuscated code will appear here...</div>
            <div id="error" class="error"></div>
        </div>
    </div>

    <script>
        let stringTable = [];
        let constantTable = [];

        function deobfuscate() {
            const input = document.getElementById('input').value.trim();
            const outputDiv = document.getElementById('output');
            const errorDiv = document.getElementById('error');
            const progressDiv = document.getElementById('progress');
            const button = document.getElementById('deobfuscateBtn');

            // Reset UI
            outputDiv.textContent = '';
            errorDiv.textContent = '';
            progressDiv.style.display = 'block';
            button.disabled = true;

            // Validate input
            if (!input) {
                errorDiv.textContent = 'Error: No code provided.';
                progressDiv.style.display = 'none';
                button.disabled = false;
                return;
            }

            try {
                console.log('Starting deobfuscation...');

                // Step 1: Extract and decode string table
                stringTable = extractStringTable(input);
                console.log('String table:', stringTable);
                if (!stringTable) {
                    throw new Error('Failed to extract string table. Ensure the code is valid MoonSec V3.');
                }

                // Step 2: Decode hexadecimal constants
                let code = decodeHexConstants(input);
                console.log('After hex decoding:', code);

                // Step 3: Decode environment manipulations
                code = decodeEnvironment(code);
                console.log('After env decoding:', code);

                // Step 4: Decode bytecode
                code = decodeBytecode(code);
                console.log('After bytecode decoding:', code);

                // Step 5: Reconstruct constant table
                code = reconstructConstantTable(code);
                console.log('After constant table:', code);

                // Step 6: Simplify VM and control flow
                code = simplifyVM(code);
                console.log('After VM simplification:', code);

                // Step 7: Emulate VM instructions
                code = emulateVMInstructions(code);
                console.log('After VM emulation:', code);

                // Step 8: Deobfuscate control flow
                code = deobfuscateControlFlow(code);
                console.log('After control flow:', code);

                // Step 9: Remove junk code and useless variables
                code = removeJunkCode(code);
                console.log('After junk removal:', code);

                // Step 10: Fix syntax errors
                code = fixSyntax(code);
                console.log('After syntax fixing:', code);

                // Step 11: Format for readability
                code = formatLuaCode(code);
                console.log('Final output:', code);

                outputDiv.textContent = code || 'No output generated. The code may be too complex.';
            } catch (err) {
                errorDiv.textContent = `Error: ${err.message}`;
                console.error('Deobfuscation error:', err);
            } finally {
                progressDiv.style.display = 'none';
                button.disabled = false;
            }
        }

        function extractStringTable(code) {
            const stringTableMatch = code.match(/s\s*=\s*"([^"]*)"/);
            if (!stringTableMatch) return null;

            const encodedStr = stringTableMatch[1];
            const result = [];
            let i = 0;

            while (i < encodedStr.length) {
                if (encodedStr[i] === '\5') break;
                if (encodedStr[i] === '\2') {
                    const length = encodedStr.charCodeAt(i + 1);
                    const bytes = encodedStr.slice(i + 2, i + 2 + length);
                    let decoded;
                    try {
                        decoded = String.fromCharCode(...bytes.split('').map(c => c.charCodeAt(0)));
                    } catch {
                        decoded = `str_${bytes.replace(/[^a-zA-Z0-9]/g, '')}`;
                    }
                    result.push(decoded);
                    i += 2 + length;
                } else if (encodedStr[i] === '\3') {
                    const length = encodedStr.charCodeAt(i + 1);
                    const decoded = encodedStr.slice(i + 2, i + 2 + length);
                    result.push(decoded !== '\0');
                    i += 2 + length;
                } else if (encodedStr[i] === '\6') {
                    const length = encodedStr.charCodeAt(i + 1);
                    const decoded = encodedStr.slice(i + 2, i + 2 + length);
                    result.push(`func_${decoded.replace(/[^a-zA-Z0-9]/g, '')}`);
                    i += 2 + length;
                } else if (encodedStr[i] === '\4') {
                    const length = encodedStr.charCodeAt(i + 1);
                    const decoded = encodedStr.slice(i + 2, i + 2 + length);
                    result.push(`ref_${decoded.replace(/[^a-zA-Z0-9]/g, '')}`);
                    i += 2 + length;
                } else if (encodedStr[i] === '\0') {
                    const length = encodedStr.charCodeAt(i + 1);
                    const decoded = encodedStr.slice(i + 2, i + 2 + length);
                    result.push(`table_${decoded.replace(/[^a-zA-Z0-9]/g, '')}`);
                    i += 2 + length;
                } else {
                    i++;
                }
            }
            return result;
        }

        function decodeHexConstants(code) {
            return code.replace(/0x[0-9a-fA-F]+/g, match => parseInt(match, 16).toString());
        }

        function decodeEnvironment(code) {
            code = code.replace(/getfenv\s*and\s*getfenv\(\)/g, '_G');
            code = code.replace(/r=(not\s*r)\s*and\s*_ENV\s*or\s*r;/g, 'r = _G;');
            code = code.replace(/_PxOySmLLeOLo/g, '_G');
            code = code.replace(/v\d+=_ENV;/g, '');
            return code;
        }

        function decodeBytecode(code) {
            const bytecodeMatches = code.match(/d\(\d+,\s*"([^"]*)"\)/g) || [];
            for (const match of bytecodeMatches) {
                const [, encoded] = match.match(/d\(\d+,\s*"([^"]*)"\)/);
                let decoded = encoded;
                const decoders = [
                    // Base64
                    () => atob(encoded.replace(/[^A-Za-z0-9+/=]/g, '')),
                    // ASCII
                    () => String.fromCharCode(...encoded.split('').map(c => c.charCodeAt(0))),
                    // XOR with common keys (42, 69, 123, 255)
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) ^ 42)).join(''),
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) ^ 69)).join(''),
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) ^ 123)).join(''),
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) ^ 255)).join(''),
                    // Shift ciphers (+1, -1, +2, -2)
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) - 1)).join(''),
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) + 1)).join(''),
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) - 2)).join(''),
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) + 2)).join(''),
                    // Rot13
                    () => encoded.replace(/[a-zA-Z]/g, c => String.fromCharCode(
                        (c.charCodeAt(0) <= 90 ? 65 : 97) + ((c.charCodeAt(0) % 26) + 13) % 26
                    )),
                    // Custom substitution (e.g., for strings like "ãÖÕã©ÑÒÆ")
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) % 128)).join('')
                ];
                for (const decoder of decoders) {
                    try {
                        decoded = decoder();
                        if (decoded && /[\w\s(){};=]/.test(decoded)) break;
                    } catch {
                        continue;
                    }
                }
                code = code.replace(match, `"${decoded.replace(/"/g, '\\"')}"`);
            }

            stringTable.forEach((item, index) => {
                const placeholder = `(ref_|table_|func_)${index}\\b`;
                code = code.replace(new RegExp(placeholder, 'g'), JSON.stringify(item));
            });

            return code;
        }

        function reconstructConstantTable(code) {
            const constantTableMatch = code.match(/c\s*=\s*{([^}]*)}/);
            if (constantTableMatch) {
                let constants = constantTableMatch[1].split(',').map(s => s.trim()).filter(s => s);
                constants = constants.map((c, i) => `${c} -- const_${i}`);
                code = code.replace(constantTableMatch[0], `c = {\n  ${constants.join(',\n  ')}\n}`);
                constantTable = constants.map(c => c.split(' -- ')[0]);
            }
            return code;
        }

        function simplifyVM(code) {
            code = code.replace(/while\s*n<\d+\s*do\s*n=n\+1;.*?end/g, '');
            code = code.replace(/e=\(e[*+-\d%]+\)\%\d+/g, '');
            code = code.replace(/if\s*e%2~=0\s*then\s*.*?else\s*.*?end/g, '');
            code = code.replace(/local\s*\w+\s*=\s*\d+;/g, '');
            code = code.replace(/n=n\+1;e=d\[n\];/g, '');
            return code;
        }

        function emulateVMInstructions(code) {
            const opcodeMap = {
                't\\[(\\d+)\\]=t\\[(\\d+)\\]\\[(\\d+)\\];': (match, r, l, s) => `t[${r}] = t[${l}][${s}];`,
                't\\[(\\d+)\\]=c\\[(\\d+)\\];': (match, r, l) => `t[${r}] = ${JSON.stringify(constantTable[l] || stringTable[l] || `const_${l}`)};`,
                't\\[(\\d+)\\]\\[(\\d+)\\]=t\\[(\\d+)\\];': (match, r, l, s) => `t[${r}][${l}] = t[${s}];`,
                't\\[(\\d+)\\]=t\\[(\\d+)\\]\\(.*?\\);': (match, r, l) => `t[${r}] = t[${l}]();`,
                't\\[(\\d+)\\]=\\(t\\[(\\d+)\\](?:~=|==)[^;]+\\);': (match, r, l) => `t[${r}] = t[${l}];`,
                'for\\s*e=(\\d+),(\\d+)\\s*do\\s*t\\[e\\]=nil;end': () => '',
                't\\[(\\d+)\\]={};': (match, r) => `t[${r}] = {};`,
                't\\[(\\d+)\\]=\\d+;': (match, r) => `t[${r}] = number;`,
                'local\\s*(\\w+)=\\(function\\([^)]*\\).*?end\\)\\(\\);': (match, var) => `local ${var} = deobfuscated_function;`,
                'v(\\d+)=string\\.char;': (match, n) => `local char${n} = string.char;`,
                'v(\\d+)=_G;': (match, n) => `local global${n} = _G;`
            };

            for (const [pattern, replacer] of Object.entries(opcodeMap)) {
                code = code.replace(new RegExp(pattern, 'g'), replacer);
            }

            code = code.replace(/c\[(\d+)\]/g, (match, index) => {
                return JSON.stringify(constantTable[index] || stringTable[index] || `const_${index}`);
            });

            return code;
        }

        function deobfuscateControlFlow(code) {
            code = code.replace(/if\s*\(t\[(\d+)\](?:~=|==)[^)]+\)\s*then\s*n=n\+1;else\s*n=(\d+);end/g, '');
            code = code.replace(/while\s*true\s*do\s*if\s*n<-\d+\s*then\s*n=n\+42\s*end\s*.*?end/g, '');
            code = code.replace(/if\s*\(\w+\[\d+\]\)\s*then\s*.*?else\s*.*?end/g, '');
            return code;
        }

        function removeJunkCode(code) {
            code = code.replace(/t\[\d+\]=0x[0-1];/g, '');
            code = code.replace(/local\s*\w+\s*=\s*\{[^}]*\};/g, '');
            code = code.replace(/;+/g, ';');
            code = code.replace(/local\s*\w+\s*=\s*function\s*\(\)\s*end;/g, '');
            code = code.replace(/local\s*v\d+\s*=\s*nil;/g, '');
            code = code.replace(/local\s*v\d+\s*=\s*string\.\w+;/g, '');
            return code;
        }

        function fixSyntax(code) {
            let openParens = (code.match(/\(/g) || []).length;
            let closeParens = (code.match(/\)/g) || []).length;
            if (openParens > closeParens) {
                code += ')'.repeat(openParens - closeParens);
            } else if (closeParens > openParens) {
                code = code.slice(0, -(closeParens - openParens));
            }

            code = code.replace(/,\s*}/g, '}');
            code = code.replace(/,,\s*/g, ',');
            code = code.replace(/;+\s*/g, ';');
            code = code.replace(/local\s*\w+\s*=\s*nil;/g, '');
            return code;
        }

        function formatLuaCode(code) {
            const lines = code.split('\n');
            let indentLevel = 0;
            const formatted = lines.map(line => {
                line = line.trim();
                if (!line) return '';
                if (line.match(/^end\b/)) indentLevel = Math.max(0, indentLevel - 1);
                const indent = '  '.repeat(indentLevel);
                if (line.match(/^(function|if|for|while)\b/)) indentLevel++;
                return indent + line;
            }).filter(line => line);
            return formatted.join('\n');
        }
    </script>
</body>
</html>
