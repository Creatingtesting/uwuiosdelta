<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Luau / MoonSec V3 — Quick Deobfuscator (best-effort)</title>
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 0; height: 100vh; display:flex; }
    .col { flex:1; padding:16px; box-sizing:border-box; display:flex; flex-direction:column; gap:8px; }
    textarea { width:100%; height:55vh; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:13px; padding:10px; box-sizing:border-box; }
    button { padding:8px 12px; cursor:pointer; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    .log { height:26vh; overflow:auto; background:#0f0f12; color:#d6d6d6; padding:8px; font-size:12px; border-radius:6px; }
    .small { font-size:12px; color:#666; }
    input[type="checkbox"] { margin-right:6px; transform:translateY(2px); }
    .meta { display:flex; gap:12px; align-items:center; }
    .rename-map { font-size:12px; color:#333; }
    pre { white-space:pre-wrap; word-break:break-word; }
  </style>
</head>
<body>
  <div class="col" style="border-right:1px solid #e6e6e6;">
    <h1>Luau deobfuscator — best-effort</h1>
    <div class="small">Paste the obfuscated Luau / MoonSec code into the left box. Use the buttons to run transformations.</div>

    <label><strong>Input (obfuscated)</strong></label>
    <textarea id="input" placeholder="Paste obfuscated Luau here..."></textarea>

    <div class="controls">
      <button id="unescape">Unescape & Collapse</button>
      <button id="evalnums">Evaluate simple numeric expressions</button>
      <button id="collapseconcat">Collapse string concatenations</button>
      <button id="rename">Normalize / Rename short names</button>
      <button id="format">Basic indent / format</button>
      <button id="all">Run all steps</button>
      <button id="download">Download result</button>
    </div>

    <div class="meta">
      <label><input type="checkbox" id="rename-checkbox" checked/>Auto-rename short vars</label>
      <div class="small">Non-printables are shown as <code>\xNN</code>.</div>
    </div>

    <label><strong>Change log</strong></label>
    <div id="log" class="log"></div>
  </div>

  <div class="col">
    <label><strong>Output (deobfuscated — best-effort)</strong></label>
    <textarea id="output" placeholder="Transformed code appears here..." readonly></textarea>

    <label><strong>Diff / Notes</strong></label>
    <div id="notes" style="height:18vh; overflow:auto; background:#fafafa; padding:8px; border-radius:6px; font-size:13px;"></div>
  </div>

<script>
/* Helper utilities */
function addLog(msg){
  const log = document.getElementById('log');
  const now = new Date().toLocaleTimeString();
  log.textContent = now + "  — " + msg + "\\n" + log.textContent;
}

/* 1) Unescape Lua string literal escapes like \\123 (decimal), \\x7F (hex), and the common \\n, \\t */
function unescapeLuaStrings(code){
  // decode only inside quoted strings
  const re = /(['"])(?:\\\\.|[^\\\\])*?\\1/gm;
  let changed = 0;
  const out = code.replace(re, s => {
    const quote = s[0];
    // strip outer quotes
    let inner = s.slice(1,-1);
    // Replace common escapes first:
    inner = inner.replace(/\\\\/g, '\\\\') // escaped backslash -> single backslash for processing
      .replace(/\\n/g, '\\n') // keep textual
      .replace(/\\r/g, '\\r')
      .replace(/\\t/g, '\\t')
      .replace(/\\'/g, "'")
      .replace(/\\"/g, '"');
    // Replace \\xHH hex
    inner = inner.replace(/\\x([0-9A-Fa-f]{1,2})/g, (m, g1) => {
      const code = parseInt(g1,16);
      return printableChar(code);
    });
    // Replace \\ddd decimal (1-3 digits). Many MoonSec uses decimal codes like \116
    inner = inner.replace(/\\([0-9]{1,3})/g, (m,g1) => {
      const code = parseInt(g1,10);
      return printableChar(code);
    });
    // Collapse sequences like "a" .. "b" later, but return with original quote
    changed++;
    // re-escape inner quotes to keep valid literal in output
    const safeInner = inner.replace(new RegExp(quote, 'g'), '\\' + quote);
    return quote + safeInner + quote;
  });
  addLog("Unescaped " + (changed) + " string literal(s).");
  return out;
}

function printableChar(code){
  if(code >= 32 && code <= 126){
    return String.fromCharCode(code);
  } else {
    // keep nonprintable as \xNN to avoid breaking script
    return "\\x" + code.toString(16).padStart(2,'0').toUpperCase();
  }
}

/* 2) Collapse adjacent string concatenations "a" .. "b" -> "ab" when both are literal strings */
function collapseConcat(code){
  // handle repeated patterns like "a" .. "b" .. "c"
  let changed = 0;
  const pattern = /(['"])((?:\\.|[^\\])*?)\\1\\s*\\.\\.\\s*(['"])((?:\\.|[^\\])*?)\\3/g;
  let out = code;
  while(true){
    const newOut = out.replace(pattern, (m, q1, s1, q2, s2) => {
      // both strings already have been unescaped earlier, but might still contain \xNN
      changed++;
      // join and preserve quote type of first
      const joined = (s1 + s2).replace(new RegExp(q1, 'g'), '\\' + q1);
      return q1 + joined + q1;
    });
    if(newOut === out) break;
    out = newOut;
  }
  addLog("Collapsed " + changed + " string concat(s).");
  return out;
}

/* 3) Evaluate simple numeric expressions: convert 0x... to decimal comment, evaluate (0x1 + 5) if purely numeric */
function evalSimpleNumbers(code){
  let changed = 0;
  // replace isolated hex literals with hex /*=dec*/ comment for visibility
  code = code.replace(/0x[0-9A-Fa-f]+/g, m => {
    const dec = parseInt(m,16);
    changed++;
    return m + " /*=" + dec + "*/";
  });
  // Evaluate simple parenthetical arithmetic literals like (0x10 + 5) when expression consists only of literals/operators
  const exprRe = /\\(([-+*\\/%\\s0-9xXa-fA-F()]+)\\)/g;
  code = code.replace(exprRe, (m,g1) => {
    // reject if contains letters other than x/A-F used in hex
    if(/[A-Za-z]/.test(g1.replace(/0x[0-9A-Fa-f]+/g, ''))){
      return m;
    }
    // try to compute by converting hex to decimal temporarily
    try{
      const safe = g1.replace(/0x[0-9A-Fa-f]+/g, h => parseInt(h,16));
      // prevent unsafe eval by allowing only digits and operators
      if(/^[0-9+\\-*/%\\s().]+$/.test(safe)){
        // eslint-disable-next-line no-eval
        const val = eval(safe);
        changed++;
        return "(" + g1 + ") /*=" + val + "*/";
      } else {
        return m;
      }
    } catch(e){
      return m;
    }
  });
  addLog("Annotated/evaluated " + changed + " numeric literal(s).");
  return code;
}

/* 4) Rename short var names to slightly more readable variants (heuristic) */
function renameShortVars(code){
  // Heuristic: rename local single-letter identifiers (a,b,c,d,e,o,l,s,t,r) when followed by '=' or ',' or 'local ' occurrences
  const candidates = ["o","l","e","n","a","t","s","d","r","f","c"];
  const mapping = {};
  let counter = 1;
  candidates.forEach(c => {
    const re = new RegExp("\\b" + c + "\\b", "g");
    // skip common Lua keywords
    if(re.test(code)){
      const newName = c + "_v" + counter++;
      mapping[c] = newName;
      code = code.replace(re, newName);
    }
  });
  addLog("Renamed " + Object.keys(mapping).length + " short var(s).");
  let notes = "Renaming map:\\n";
  for(const k in mapping) notes += k + " → " + mapping[k] + "\\n";
  return {code, notes};
}

/* 5) Simple indentation (keyword brace-based: function, end, do, then) */
function simpleFormat(code){
  const lines = code.split(/\\n/);
  let indent = 0;
  const out = lines.map(line => {
    const trimmed = line.trim();
    // dedent before lines starting with end/elseif/else/until
    if(/^\\b(end|elseif|else|until)\\b/.test(trimmed)){
      indent = Math.max(0, indent - 1);
    }
    const outLine = "  ".repeat(indent) + trimmed;
    // increase indent after function/do/then/repeat (on same line)
    if(/\\b(function|do|then|repeat)\\b/.test(trimmed) && !/\\bend\\b/.test(trimmed)){
      indent++;
    }
    return outLine;
  });
  addLog("Applied basic formatting.");
  return out.join("\\n");
}

/* Wiring buttons */
document.getElementById('unescape').addEventListener('click', () => {
  const inp = document.getElementById('input').value;
  if(!inp){ addLog("No input"); return; }
  const step1 = unescapeLuaStrings(inp);
  const step2 = collapseConcat(step1);
  document.getElementById('output').value = step2;
  document.getElementById('notes').textContent = "Ran Unescape & Collapse.";
});

document.getElementById('collapseconcat').addEventListener('click', () => {
  const out = document.getElementById('output').value || document.getElementById('input').value;
  if(!out){ addLog("No input"); return; }
  const res = collapseConcat(out);
  document.getElementById('output').value = res;
  document.getElementById('notes').textContent = "Collapsed concatenations.";
});

document.getElementById('evalnums').addEventListener('click', () => {
  const out = document.getElementById('output').value || document.getElementById('input').value;
  if(!out){ addLog("No input"); return; }
  const res = evalSimpleNumbers(out);
  document.getElementById('output').value = res;
  document.getElementById('notes').textContent = "Evaluated/annotated numeric literals.";
});

document.getElementById('rename').addEventListener('click', () => {
  const out = document.getElementById('output').value || document.getElementById('input').value;
  if(!out){ addLog("No input"); return; }
  const res = renameShortVars(out);
  document.getElementById('output').value = res.code;
  document.getElementById('notes').textContent = res.notes;
});

document.getElementById('format').addEventListener('click', () => {
  const out = document.getElementById('output').value || document.getElementById('input').value;
  if(!out){ addLog("No input"); return; }
  const res = simpleFormat(out);
  document.getElementById('output').value = res;
  document.getElementById('notes').textContent = "Applied basic indentation.";
});

document.getElementById('all').addEventListener('click', () => {
  const inp = document.getElementById('input').value;
  if(!inp){ addLog("No input"); return; }
  let s = unescapeLuaStrings(inp);
  s = collapseConcat(s);
  s = evalSimpleNumbers(s);
  const renamed = renameShortVars(s);
  s = renamed.code;
  s = simpleFormat(s);
  document.getElementById('output').value = s;
  document.getElementById('notes').textContent = "All steps run. Renaming map in notes.";
});

document.getElementById('download').addEventListener('click', () => {
  const out = document.getElementById('output').value;
  if(!out){ addLog("Nothing to download."); return; }
  const blob = new Blob([out], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'deobfuscated.lua.txt';
  a.click();
  URL.revokeObjectURL(url);
  addLog("Downloaded result as deobfuscated.lua.txt");
});

/* quick sample placeholder */
document.getElementById('input').placeholder = "Paste your MoonSec-protected Luau here. Try 'All steps' first.";

addLog("Tool ready — paste code and press 'All steps'.");
</script>
</body>
</html>
