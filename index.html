<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Luau Code Inspector — Local Analyzer</title>
<style>
  :root{--bg1:#1e1e2f;--bg2:#2a2a4e;--accent1:#00ffff;--accent2:#ff00ff}
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:linear-gradient(135deg,var(--bg1),var(--bg2));color:#fff}
  .wrap{max-width:980px;margin:28px auto;padding:22px;background:rgba(0,0,0,0.6);border-radius:12px;box-shadow:0 8px 40px rgba(0,0,0,.6);backdrop-filter:blur(6px)}
  h1{margin:0 0 12px;font-size:1.8rem;color:var(--accent1);text-shadow:0 0 8px rgba(0,255,255,.12)}
  .meta{font-size:.9rem;color:var(--accent1);float:right}
  textarea{width:100%;min-height:200px;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,.06);background:#26263c;color:#eaeaea;font-family:Courier,monospace;box-sizing:border-box}
  .row{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
  .col{flex:1 1 200px;min-width:180px}
  label{display:block;font-size:.9rem;margin-bottom:6px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{background:linear-gradient(45deg,var(--accent1),var(--accent2));border:none;color:#111;padding:10px 14px;border-radius:8px;cursor:pointer}
  #output{white-space:pre-wrap;font-family:Courier,monospace;background:#161622;border:1px solid rgba(255,0,255,.15);padding:12px;border-radius:8px;max-height:340px;overflow:auto;margin-top:10px}
  .foot{margin-top:12px;color:#bbb;font-size:.85rem}
  .note{color:#ffd3d3;background:rgba(255,0,0,.06);padding:8px;border-radius:6px;margin-top:8px}
  input[type="text"]{width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,.06);background:#222;color:#fff}
  .small{font-size:.85rem;color:#cfefff}
</style>
</head>
<body>
  <div class="wrap">
    <div style="display:flex;align-items:center;gap:12px">
      <h1>Luau Code Inspector</h1>
      <div class="meta">Local analyzer • v1.0</div>
    </div>

    <p class="small">Paste obfuscated Luau/Lua code you own here. This runs <strong>only in your browser</strong> and will not fetch, execute, or decompile remote sources.</p>

    <textarea id="inputCode" placeholder="Paste Luau code you own..."></textarea>

    <div class="row" style="margin-top:10px">
      <div class="col">
        <label><input type="checkbox" id="optUnescape" checked> Unescape ASCII &amp; hex escapes (\123, \x7F)</label>
        <label><input type="checkbox" id="optStringChar" checked> Resolve string.char(...) calls (local-only numeric sequences)</label>
        <label><input type="checkbox" id="optConcat" checked> Resolve simple string concatenations ("a".."b")</label>
        <label><input type="checkbox" id="optBase64" checked> Try Base64 decode on embedded strings</label>
        <label><input type="checkbox" id="optXor" > Try XOR decode when you provide a key</label>
        <div style="margin-top:6px">
          <label for="xorKey">XOR key (text):</label>
          <input id="xorKey" type="text" placeholder="optional key for XOR decoding" />
        </div>
      </div>

      <div class="col">
        <label><input type="checkbox" id="optRename" checked> Heuristic variable renaming (no semantics change)</label>
        <label><input type="checkbox" id="optInline" checked> Inline trivial functions (return constants only)</label>
        <label><input type="checkbox" id="optNumEval" checked> Simplify simple numeric expressions</label>
        <label><input type="checkbox" id="optPretty" checked> Pretty-print (indent)</label>
        <label><input type="checkbox" id="optStripComments" checked> Remove comments &amp; zero-width chars</label>
      </div>
    </div>

    <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap">
      <div class="controls">
        <button onclick="analyze()">Analyze (local)</button>
        <button onclick="copyOutput()">Copy Output</button>
        <button onclick="downloadOutput()">Download .lua</button>
        <button onclick="resetAll()">Reset</button>
      </div>
    </div>

    <div id="output" aria-live="polite">Results will appear here after you click Analyze.</div>

    <div class="foot">
      <div class="note"><strong>Legal / safety note:</strong> This inspector is intended for use on code you own or have explicit permission to analyze. It will not contact external servers, perform any decompilation of remote scripts, or execute the code you provide. I will not help you use it to obtain other people's private/obfuscated sources without permission.</div>
      <p style="margin-top:8px">If you want more advanced features (for your own code) — e.g., better renaming rules, additional decode algorithms, or integration with an offline decompiler you already own — tell me what exact feature you want and I can safely expand this analyzer.</p>
    </div>
  </div>

<script>
/* Safe local-only analyzer. Nothing here fetches or executes code. */
function safeReplaceAll(str, re, fn){ let last; do { last=str; str=str.replace(re, fn); } while(str!==last); return str; }

/* Basic helpers */
const asciiTable = (n=> {
  try { return String.fromCharCode(Number(n)); } catch(e){ return ''; }
});

/* Unescape common Lua-style escapes inside quoted strings */
function unescapeLuauStringLiteral(s){
  // s assumes no surrounding quotes; only internal escapes
  let out='', i=0;
  while(i<s.length){
    if(s[i]==='\\'){
      i++;
      if(i>=s.length){ out+='\\'; break; }
      const c=s[i];
      if(c==='x'){ // hex \xHH
        const hex=(s.substr(i+1,2) || '');
        if(/^[0-9A-Fa-f]{2}$/.test(hex)){ out += String.fromCharCode(parseInt(hex,16)); i+=3; continue; }
        out += '\\x'; continue;
      }
      if(/\d/.test(c)){ // decimal \123
        let num='';
        while(/\d/.test(s[i]) && num.length<3){ num+=s[i]; i++; }
        out += String.fromCharCode(Number(num)); continue;
      }
      const map={'n':'\n','r':'\r','t':'\t','\\':'\\','"':'"',"\'":"'",'a':'\x07','b':'\b','f':'\f','v':'\v'};
      out += map[c] || c;
      i++;
    } else { out+=s[i++]; }
  }
  return out;
}

/* Safe numeric evaluator for small integer expressions (no eval, simple ops) */
function evalSimpleNumeric(expr){
  // allow digits, spaces and + - * / ^ and parentheses. evaluate by parsing tokens (very small)
  if(!/^[0-9\+\-\*\/\^\(\)\s]+$/.test(expr)) return expr;
  try{
    // implement a safe parser via Function is avoided; implement a tiny shunting-yard
    const ops={'+':1,'-':1,'*':2,'/':2,'^':3};
    const isOp=(c)=>ops.hasOwnProperty(c);
    // tokenize
    let tokens=[], i=0;
    while(i<expr.length){
      const ch=expr[i];
      if(/\s/.test(ch)){ i++; continue; }
      if(/\d/.test(ch)){ let n=''; while(/\d/.test(expr[i])){n+=expr[i++]} tokens.push({t:'num',v:parseInt(n,10)}); continue; }
      if(isOp(ch) || ch==='('||ch===')'){ tokens.push({t:'op',v:ch}); i++; continue; }
      return expr;
    }
    // shunting yard -> RPN
    let outQ=[], opS=[];
    for(const tk of tokens){
      if(tk.t==='num'){ outQ.push(tk.v); }
      else if(tk.v==='('){ opS.push('('); }
      else if(tk.v===')'){ while(opS.length && opS[opS.length-1] !== '(') outQ.push(opS.pop()); opS.pop(); }
      else {
        while(opS.length && opS[opS.length-1]!=='(' && ((ops[opS[opS.length-1]]>ops[tk.v]) || (ops[opS[opS.length-1]]===ops[tk.v] && tk.v!=='^'))){
          outQ.push(opS.pop());
        }
        opS.push(tk.v);
      }
    }
    while(opS.length) outQ.push(opS.pop());
    // eval RPN
    let st=[];
    for(const t of outQ){
      if(typeof t === 'number'){ st.push(t); }
      else {
        const b=st.pop(), a=st.pop();
        if(t==='+') st.push(a+b);
        else if(t==='-') st.push(a-b);
        else if(t==='*') st.push(a*b);
        else if(t==='/') st.push(a/b);
        else if(t==='^') st.push(Math.pow(a,b));
      }
    }
    return (st.length===1)? String(st[0]) : expr;
  }catch(e){ return expr; }
}

/* Base64 decode helper (browser-safe) */
function tryBase64Decode(s){
  try{
    // only attempt if valid base64 characters and reasonable length
    if(!/^[A-Za-z0-9+\/=]+$/.test(s)) return null;
    // atob may throw on invalid padding
    const decoded = atob(s);
    // only return if printable-ish
    if(/^[\x09\x0A\x0D\x20-\x7E]*$/.test(decoded)) return decoded;
    return null;
  } catch(e){ return null; }
}

/* XOR helper: key is string; returns decoded text (bytewise xor) */
function xorDecodeWithKey(s, key){
  if(!key) return null;
  let out='';
  for(let i=0;i<s.length;i++){
    out += String.fromCharCode(s.charCodeAt(i) ^ key.charCodeAt(i % key.length));
  }
  // sanity: return printable only
  if(/^[\x09\x0A\x0D\x20-\x7E]*$/.test(out)) return out;
  return out;
}

/* Resolve simple string.char(...) calls like string.char(65,66,..) into "AB" */
function resolveStringCharCalls(src){
  return safeReplaceAll(src, /\b(?:string|string\.char|strchr|chr)\s*\(\s*([0-9\+\-\*\,\s\(\)]+)\s*\)/g, (m,p)=> {
    try{
      // split by commas, evaluate simple numeric subexpr
      const parts = p.split(',').map(x=>x.trim()).filter(Boolean);
      const chars = parts.map(part => {
        const simplified = evalSimpleNumeric(part);
        if(/^[0-9]+$/.test(simplified)) return String.fromCharCode(Number(simplified));
        return null;
      });
      if(chars.every(c=>c!==null)) return `"${chars.join('')}"`;
      return m;
    } catch(e){ return m; }
  });
}

/* Resolve simple concatenation of string literals: "a".."b" => "ab" */
function resolveConcats(src){
  return safeReplaceAll(src, /("([^"\\]|\\.)*")\s*\.\.\s*("([^"\\]|\\.)*")/g, (m,a,b)=> {
    // remove quotes then unescape
    const s1 = a.slice(1,-1), s2 = b.slice(1,-1);
    return `"${unescapeLuauStringLiteral(s1)+unescapeLuauStringLiteral(s2)}"`;
  });
}

/* Inline trivial functions that only return a constant: local function f() return "x" end -> local f = "x" */
function inlineTrivialReturns(src){
  return src.replace(/local\s+function\s+(\w+)\s*\(\s*\)\s*return\s+((?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|[0-9\+\-\*\/\s\(\)]+))\s*end/g, (m,name,ret)=> {
    // try to simplify numeric returns
    const trimmed = ret.trim();
    if(/^".*"$/.test(trimmed) || /^'.*'$/.test(trimmed)) return `local ${name} = ${trimmed}`;
    const evaled = evalSimpleNumeric(trimmed);
    if(/^[0-9\.\-]+$/.test(evaled)) return `local ${name} = ${evaled}`;
    return m;
  });
}

/* Heuristic variable renaming (only local names) - purely cosmetic */
function renameLocals(src){
  const names = new Map();
  let counter = 1;
  return src.replace(/\blocal\s+([A-Za-z_]\w*)\b/g, (m,name) => {
    if(name.length>6 && /^_?0x/.test(name) && !names.has(name)){
      names.set(name, 'var'+(counter++));
    }
    return m;
  }).replace(/\b(_?0x[a-fA-F0-9]{4,})\b/g, (m,old) => names.get(old) || old);
}

/* Pretty printer: very small indentation helper */
function prettyPrint(src){
  const lines = src.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  let indent=0; const out=[];
  for(const ln of lines){
    if(/^\bend\b/.test(ln) || /^\belseif\b/.test(ln) || /^\belse\b/.test(ln)){ indent = Math.max(0, indent-1); }
    out.push('  '.repeat(indent) + ln);
    if(/\b(function|then|do|repeat)\b/.test(ln) && !/\bend\b/.test(ln)) indent++;
  }
  return out.join('\n');
}

/* Remove comments & zero-widths */
function stripCommentsAndHidden(src){
  // remove long comments -- cautious: only local text
  src = src.replace(/--\[\[[\s\S]*?\]\]/g, '');
  src = src.replace(/--[^\n]*$/gm, '');
  src = src.replace(/[\u200B-\u200D\u202A-\u202E\u2060-\u206F\uFEFF]/g, '');
  return src;
}

/* Main analyze function */
function analyze(){
  let src = document.getElementById('inputCode').value || '';
  if(!src.trim()){ document.getElementById('output').textContent = 'No input code.'; return; }

  // options
  const optUnescape = document.getElementById('optUnescape').checked;
  const optStringChar = document.getElementById('optStringChar').checked;
  const optConcat = document.getElementById('optConcat').checked;
  const optBase64 = document.getElementById('optBase64').checked;
  const optXor = document.getElementById('optXor').checked;
  const xorKey = (document.getElementById('xorKey').value || '').trim();
  const optRename = document.getElementById('optRename').checked;
  const optInline = document.getElementById('optInline').checked;
  const optNumEval = document.getElementById('optNumEval').checked;
  const optPretty = document.getElementById('optPretty').checked;
  const optStripComments = document.getElementById('optStripComments').checked;

  try {
    if(optStripComments) src = stripCommentsAndHidden(src);

    if(optNumEval){
      // simple numeric expression simplifier (parenthesized small expressions)
      src = src.replace(/\(([0-9\+\-\*\/\s\^]+)\)/g, (m,p)=> {
        const s = evalSimpleNumeric(p);
        return (s===p)? m : s;
      });
    }

    if(optStringChar) src = resolveStringCharCalls(src);

    if(optConcat) src = resolveConcats(src);

    if(optUnescape){
      // unescape string literals
      src = safeReplaceAll(src, /(["'])(?:\\.|[^\\])*?\1/g, (m)=> {
        const q = m[0]; const inner = m.slice(1,-1);
        const dec = unescapeLuauStringLiteral(inner);
        // re-escape quotes inside
        return q + dec.replace(new RegExp(q,'g'), '\\'+q) + q;
      });
    }

    if(optBase64){
      // try to decode quoted base64 strings
      src = src.replace(/(["'])([A-Za-z0-9+\/=]{8,})\1/g, (m,quote,content) => {
        const dec = tryBase64Decode(content);
        return dec ? (quote+dec+quote) : m;
      });
    }

    if(optXor && xorKey){
      // attempt xor decode of quoted strings
      src = src.replace(/(["'])([^"']{4,200})\1/g, (m,quote,content) => {
        const dec = xorDecodeWithKey(content, xorKey);
        return dec ? (quote+dec+quote) : m;
      });
    }

    if(optInline) src = inlineTrivialReturns(src);

    if(optRename) src = renameLocals(src);

    if(optPretty) src = prettyPrint(src);

    document.getElementById('output').textContent = src;
  } catch(err){
    document.getElementById('output').textContent = 'Error during analysis: ' + err.message;
  }
}

function copyOutput(){
  const txt = document.getElementById('output').textContent || '';
  if(navigator.clipboard){
    navigator.clipboard.writeText(txt).then(()=> alert('Copied to clipboard.'));
  } else {
    alert('Clipboard not available.');
  }
}

function downloadOutput(){
  const text = document.getElementById('output').textContent || '';
  const blob = new Blob([text], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'inspected.lua'; document.body.appendChild(a);
  a.click(); a.remove(); URL.revokeObjectURL(url);
}

function resetAll(){
  document.getElementById('inputCode').value = '';
  document.getElementById('output').textContent = 'Results will appear here after you click Analyze.';
  document.getElementById('xorKey').value = '';
}
</script>
</body>
</html>
