<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>LuaU Deobfuscater (Light) — Safe Semantic Rename</title>
<style>
:root{--bg:#071022;--panel:#0b1530;--accent:#00e6ff}
body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,monospace;background:linear-gradient(135deg,var(--bg),#07162a);color:#dff;display:flex;align-items:center;justify-content:center;height:100vh;padding:14px}
.container{width:100%;max-width:1000px;background:linear-gradient(180deg,var(--panel),#061224);border-radius:12px;padding:16px;box-shadow:0 10px 40px rgba(0,0,0,0.6)}
header{display:flex;align-items:center;gap:12px;margin-bottom:8px}
h1{margin:0;font-size:1.1rem;color:var(--accent)}
.row{display:flex;gap:10px;align-items:center;margin:10px 0;flex-wrap:wrap}
.col{flex:1;min-width:300px}
textarea{width:100%;height:260px;background:#061026;color:#cfe;padding:12px;border-radius:8px;border:1px solid rgba(0,230,255,0.06);font-family:monospace;resize:vertical}
.controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
button{background:linear-gradient(90deg,var(--accent),#b14cff);border:0;padding:8px 12px;border-radius:8px;color:#001;font-weight:700;cursor:pointer}
label{font-size:.9rem;color:#cfe}
#output{background:#041021;color:#dff;padding:12px;border-radius:8px;border:1px solid rgba(177,76,255,0.06);height:300px;overflow:auto;font-family:monospace;white-space:pre-wrap}
.status{font-size:.9rem;color:#9ff;margin-top:8px}
.spacer{flex:1}
small.note{color:#9bd;font-size:.85rem}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>LuaU Deobfuscater (Light)</h1>
    <small class="note">Safe semantic renaming & improved decoding — runs entirely in your browser.</small>
  </header>

  <div style="display:flex;gap:12px;">
    <div class="col">
      <label>Obfuscated input</label>
      <textarea id="inputCode" placeholder="Paste obfuscated Luau code here..."></textarea>
      <div class="controls">
        <button id="deepBtn">Deep Deobfuscate</button>
        <button id="fullBtn">Full Deep Clean</button>
        <button id="quickBtn">Quick Pass</button>
        <button id="stripBtn">Strip Junk</button>
        <button id="copyBtn">Copy Output</button>
        <div class="spacer"></div>
        <label><input type="checkbox" id="beautify" checked/> Beautify</label>
        <label><input type="checkbox" id="xorBrute" checked/> XOR brute</label>
        <label><input type="checkbox" id="extractLoad" checked/> Extract loadstring</label>
      </div>
    </div>

    <div class="col">
      <label>Deobfuscated output</label>
      <div id="output">Output will appear here...</div>
      <div class="status" id="status">Idle</div>
    </div>
  </div>
</div>

<script>
(function(){

function setStatus(t){document.getElementById('status').textContent=t}
function setOutput(t){const o=document.getElementById('output'); o.textContent=t; o.scrollTop=o.scrollHeight}
function safeAtob(s){ try { return decodeURIComponent(escape(window.atob(s))) } catch(e) { try { return window.atob(s) } catch(e2) { return null } } }
function isAscii(s){ if(typeof s!=='string') return false; for(let i=0;i<s.length;i++){const c=s.charCodeAt(i); if(c===0||c>127) return false } return true }
function unquote(tok){ if(tok.length>=2 && (tok[0]==='"' || tok[0]==="'") && tok[tok.length-1]===tok[0]) return tok.slice(1,-1).replace(/\\n/g,'\n').replace(/\\r/g,'\r').replace(/\\"/g,'"').replace(/\\'/g,"'"); return tok }
function quoteLua(s,q='"'){ return q + s.replace(new RegExp(q,'g'),'\\'+q) + q }
function looksLikeBase64(s){ if(typeof s!=='string') return false; const t=s.replace(/\s+/g,''); return t.length>=4 && t.length%4===0 && /^[A-Za-z0-9+/=]+$/.test(t) }
function hexToText(h){ try{ h=h.replace(/[^0-9a-fA-F]/g,''); if(h.length%2!==0) return null; let out=''; for(let i=0;i<h.length;i+=2) out+=String.fromCharCode(parseInt(h.substr(i,2),16)); return out }catch(e){return null} }
function tryUrlDecode(s){ try{ return decodeURIComponent(s) }catch(e){ return null } }
function rot13(s){ return s.replace(/[A-Za-z]/g,function(c){ const b = c<='Z'?65:97; return String.fromCharCode((c.charCodeAt(0)-b+13)%26 + b) }) }

// tokenize code into array of {type:'string'|'comment'|'ident'|'other', text }
function tokenizePreserve(code){
  const tokens = []
  const regex = /--\[\[[\s\S]*?\]\]|--[^\n]*|("([^"\\]|\\.)*"|'([^'\\]|\\.)*')|[A-Za-z_][A-Za-z0-9_]*|./g
  let m
  while((m = regex.exec(code)) !== null){
    if(m[0].startsWith('--[[')) tokens.push({type:'comment', text:m[0]})
    else if(m[0].startsWith('--')) tokens.push({type:'comment', text:m[0]})
    else if(m[1]) tokens.push({type:'string', text:m[1]})
    else if(/^[A-Za-z_][A-Za-z0-9_]*$/.test(m[0])) tokens.push({type:'ident', text:m[0]})
    else tokens.push({type:'other', text:m[0]})
  }
  return tokens
}

// reconstruct code from tokens
function tokensToString(tokens){ return tokens.map(t=>t.text).join('') }

// replace identifiers in tokens using map; safe because strings/comments are separate
function replaceIdTokens(tokens, map){
  for(let t of tokens){
    if(t.type==='ident' && map.hasOwnProperty(t.text)) t.text = map[t.text]
  }
  return tokens
}

// decode string.char(65,66,67) -> "ABC"
function decodeStringCharCalls(code){
  return code.replace(/string\.char\s*\(\s*([0-9,\s]+)\s*\)/gi, function(_, nums){
    try{
      const arr = nums.split(',').map(x=>parseInt(x.trim())).filter(n=>!isNaN(n) && n>=0 && n<=255)
      if(arr.length===0) return _
      const s = arr.map(n=>String.fromCharCode(n)).join('')
      if(!isAscii(s)) return _
      return quoteLua(s,'"')
    }catch(e){ return _ }
  })
}

// collapse "a".."b" chains repeatedly
function collapseConcats(code){
  let prev
  do {
    prev = code
    code = code.replace(/(['"])([\s\S]*?)\1\s*\.\.\s*(['"])([\s\S]*?)\3/g, function(_, q1, a, q2, b){
      try{
        const merged = unquote(q1 + a + q1) + unquote(q2 + b + q2)
        if(!isAscii(merged)) return _
        return quoteLua(merged, '"')
      }catch(e){ return _ }
    })
  } while(code !== prev)
  return code
}

// decode string literal tokens if they are base64/hex/url/rot13
function decodeLiteralsByHeuristics(code, opts){
  const tokens = tokenizePreserve(code)
  for(let t of tokens){
    if(t.type !== 'string') continue
    const q = t.text[0]
    const inner = unquote(t.text)
    if(inner.length===0) continue
    if(looksLikeBase64(inner)){
      const dec = safeAtob(inner)
      if(dec && isAscii(dec)) { t.text = q + dec + q; continue }
    }
    const hx = hexToText(inner)
    if(hx && isAscii(hx)){ t.text = q + hx + q; continue }
    const ud = tryUrlDecode(inner)
    if(ud && isAscii(ud)){ t.text = q + ud + q; continue }
    const r13 = rot13(inner)
    if(r13 && isAscii(r13) && /local|function|print|game|Players/.test(r13)) { t.text = q + r13 + q; continue }
    // try small XOR brute (1..64) only if enabled
    if(opts && opts.xorBrute){
      for(let k=1;k<=64;k++){
        let out = ''
        for(let i=0;i<inner.length;i++) out += String.fromCharCode(inner.charCodeAt(i) ^ k)
        if(isAscii(out) && /local|function|print|game|Players/.test(out)){
          t.text = q + out + q
          break
        }
      }
    }
  }
  return tokensToString(tokens)
}

// brute-force XOR on string literals (optional heavier)
function bruteForceXorOnLiterals(code, maxKey){
  maxKey = typeof maxKey === 'number' ? maxKey : 255
  const tokens = tokenizePreserve(code)
  for(let t of tokens){
    if(t.type !== 'string') continue
    const q = t.text[0], inner = unquote(t.text)
    if(inner.length < 4) continue
    for(let k=1;k<=maxKey;k++){
      let out = ''
      for(let i=0;i<inner.length;i++) out += String.fromCharCode(inner.charCodeAt(i) ^ k)
      if(isAscii(out) && /local|function|print|game|Players|workspace/.test(out)){
        t.text = q + out + q
        break
      }
    }
  }
  return tokensToString(tokens)
}

// unwrap wrappers like b64decode("...") and xorDecode("...",N) when they contain literal encoded content
function unwrapWrapperCalls(code){
  code = code.replace(/b64decode\s*\(\s*("([^"\\]|\\.)*"|'([^'\\]|\\.)*')\s*\)/g, function(m, p1){
    const inner = unquote(p1)
    if(!inner) return m
    if(looksLikeBase64(inner)){
      const dec = safeAtob(inner)
      if(dec && isAscii(dec)) return quoteLua(dec, p1[0])
    }
    return m
  })
  code = code.replace(/xorDecode\s*\(\s*("([^"\\]|\\.)*"|'([^'\\]|\\.)*')\s*,\s*(\d{1,3})\s*\)/g, function(m, p1, p2, p3, keyStr){
    const inner = unquote(p1)
    const key = parseInt(keyStr, 10)
    if(!inner || isNaN(key)) return m
    let out = ''
    for(let i=0;i<inner.length;i++) out += String.fromCharCode(inner.charCodeAt(i) ^ key)
    if(isAscii(out)) return quoteLua(out, p1[0])
    return m
  })
  return code
}

// safe loadstring extraction: only extract when argument is a string and decodes to ascii
function extractLoadstring(code){
  return code.replace(/loadstring\s*\(\s*("([^"\\]|\\.)*"|'([^'\\]|\\.)*')\s*\)/g, function(m, p1){
    const inner = unquote(p1)
    if(!inner) return m
    if(looksLikeBase64(inner)){
      const dec = safeAtob(inner)
      if(dec && isAscii(dec)) return dec
    }
    // if inner looks like escaped code (contains newline and lua keywords), return inner
    if(inner.indexOf('\\n') !== -1 && /local|function|end|print|game/.test(inner)) return inner
    return m
  })
}

// remove junk patterns conservatively
function removeJunk(code){
  let out = code
  out = out.replace(/if\s+_[A-Za-z0-9]{3,}\s*==\s*math\.random\s*\([^\)]*\)\s*then[\s\S]*?end/g, '')
  out = out.replace(/local\s+_[A-Za-z0-9]{3,}\s*=[^\n]+\n/g, '')
  out = out.replace(/function\s+_[A-Za-z0-9]{3,}\([^)]*\)\s*[\s\S]*?end/g, '')
  out = out.replace(/;\s*$/gm,'') // remove stray semicolons
  return out
}

// identify obfuscated names: conservative
function isObfuscatedName(name){
  if(!name) return false
  if(/^_[A-Za-z0-9]{3,}$/.test(name)) return true
  if(/^v[0-9A-Za-z]{2,}$/.test(name)) return true
  if(name.length >= 10) return true
  // many uppercase sequences: likely obfuscated
  if(/[A-Z]{3,}/.test(name)) return true
  // too noisy: many unique chars
  const uniq = new Set(name.split('')).size
  if(name.length >=5 && uniq / name.length > 0.75) return true
  return false
}

// collect local declarations safely (simple heuristic)
function collectLocalDeclarations(code){
  const decls = []
  const regex = /\blocal\s+([A-Za-z_][A-Za-z0-9_]*)\s*(?:=\s*([^;\n]+))?/g
  let m
  while((m = regex.exec(code)) !== null){
    decls.push({name: m[1], value: m[2] ? m[2].trim() : null, index: m.index})
  }
  return decls
}

// generate a safe, semantic name from value if confident
function nameFromValue(value, usedNames){
  usedNames = usedNames || new Set()
  if(!value) return null
  const s = value.trim()
  if(/^['"]/.test(s)){
    const inner = unquote(s.split(/\)\s*$/)[0])
    if(inner.length===0) return null
    let base = inner.replace(/[^A-Za-z0-9 ]+/g,' ').trim().split(/\s+/).slice(0,3).join('')
    base = base || 'Text'
    base = base.replace(/^\d+/,'')
    const candidate = base[0] ? base[0].toUpperCase() + base.slice(1) : 'Text'
    let out = candidate
    let i=1
    while(usedNames.has(out)) { out = candidate + i; i++ }
    usedNames.add(out)
    return out
  }
  if(/^\d+$/.test(s)) {
    let out = 'Count'
    let i=1
    while(usedNames.has(out+i)) i++
    out = out + i
    usedNames.add(out)
    return out
  }
  if(/^function\b/.test(s) || s.indexOf('function')===0) {
    let base = 'Do'
    let i=1
    while(usedNames.has(base + i)) i++
    const out = base + i
    usedNames.add(out)
    return out
  }
  if(/\btrue\b|\bfalse\b/.test(s)) {
    let out = 'IsFlag'
    let i=1
    while(usedNames.has(out + i)) i++
    usedNames.add(out + i)
    return out + i
  }
  return null
}

// perform safe semantic renaming: only locals that are obfuscated and not used as table fields
function safeSemanticRename(code){
  const decls = collectLocalDeclarations(code)
  if(decls.length===0) return code
  const tokens = tokenizePreserve(code)
  const usedNames = new Set()
  for(const t of tokens) if(t.type==='ident') usedNames.add(t.text)
  const map = {}
  const usedNew = new Set(usedNames)
  for(const d of decls){
    const name = d.name
    if(!isObfuscatedName(name)) continue
    // make sure it's not used as a field: pattern like obj.<name> or :<name>
    const fieldRegex = new RegExp('\\.' + name + '\\b|\\:' + name + '\\b')
    if(fieldRegex.test(code)) continue
    // attempt to generate a semantic name from value
    let candidate = null
    try { candidate = nameFromValue(d.value, usedNew) } catch(e) { candidate = null }
    if(!candidate){
      // fallback: derive short readable name from original but not numeric-only
      let cleaned = name.replace(/[^A-Za-z]/g,'')
      if(cleaned.length>=3) candidate = cleaned[0].toUpperCase() + cleaned.slice(1)
      else candidate = 'Var' + (Math.floor(Math.random()*9000)+1000)
      while(usedNew.has(candidate)) candidate += '_'
      usedNew.add(candidate)
    }
    map[name] = candidate
  }
  if(Object.keys(map).length===0) return code
  // replace identifiers safely using tokens (so we never replace inside strings/comments)
  const newTokens = tokens.map(t=>{
    if(t.type==='ident' && map.hasOwnProperty(t.text)) return {type:t.type, text: map[t.text]}
    return t
  })
  return tokensToString(newTokens)
}

// simple beautifier
function beautify(code){
  const lines = code.replace(/\r\n/g,'\n').replace(/\r/g,'\n').split('\n')
  let indent = 0, out = []
  for(let L of lines){
    let line = L.trim()
    if(line===''){ out.push(''); continue }
    if(/^(end|until|else|elseif)\b/.test(line)) indent = Math.max(0, indent-1)
    out.push('  '.repeat(indent) + line)
    if(/\b(then|do|function|repeat)\b/.test(line)) indent++
  }
  return out.join('\n').replace(/\n{3,}/g,'\n\n').trim()
}

async function deepDeobfuscate(fullClean){
  let code = document.getElementById('inputCode').value || ''
  if(!code){ alert('Paste code first'); return }
  const doXor = document.getElementById('xorBrute').checked
  const doExtract = document.getElementById('extractLoad').checked
  const doBeaut = document.getElementById('beautify').checked
  let iter = 0, changedAny = false
  const maxIter = 25
  while(iter++ < maxIter){
    const before = code
    code = decodeStringCharCalls(code)
    code = collapseConcats(code)
    code = unwrapWrapperCalls(code)
    code = decodeLiteralsByHeuristics(code, {xorBrute: false})
    if(doXor) code = bruteForceXorOnLiterals(code, 255)
    if(doExtract) code = extractLoadstring(code)
    code = removeJunk(code)
    code = safeSemanticRename(code)
    if(fullClean){
      code = code.replace(/__\w+__/g,'').replace(/\b__G__\b/g,'')
    }
    setStatus('Pass ' + iter + (code !== before ? ' — changes' : ' — no changes'))
    changedAny = changedAny || (code !== before)
    await new Promise(r => setTimeout(r,10))
    if(code === before) break
  }
  if(doBeaut) code = beautify(code)
  setOutput(code || '-- no output --')
  setStatus('Finished — iterations: ' + iter + (changedAny ? ' (changes made)' : ' (no changes)'))
}

function quickPass(){
  let code = document.getElementById('inputCode').value || ''
  if(!code){ alert('Paste code first'); return }
  code = decodeStringCharCalls(code)
  code = collapseConcats(code)
  code = unwrapWrapperCalls(code)
  code = decodeLiteralsByHeuristics(code, {xorBrute: true})
  code = removeJunk(code)
  code = safeSemanticRename(code)
  if(document.getElementById('beautify').checked) code = beautify(code)
  setOutput(code)
  setStatus('Quick pass complete')
}

function stripOnly(){
  let code = document.getElementById('inputCode').value || ''
  if(!code){ alert('Paste code first'); return }
  code = removeJunk(code)
  if(document.getElementById('beautify').checked) code = beautify(code)
  setOutput(code)
  setStatus('Junk stripped')
}

function copyOutput(){
  const out = document.getElementById('output').textContent || ''
  if(!out){ alert('Nothing to copy'); return }
  navigator.clipboard.writeText(out).then(()=>setStatus('Copied to clipboard'), ()=>setStatus('Copy failed'))
}

document.getElementById('deepBtn').addEventListener('click', ()=>deepDeobfuscate(false))
document.getElementById('fullBtn').addEventListener('click', ()=>deepDeobfuscate(true))
document.getElementById('quickBtn').addEventListener('click', quickPass)
document.getElementById('stripBtn').addEventListener('click', stripOnly)
document.getElementById('copyBtn').addEventListener('click', copyOutput)

})();
</script>
</body>
</html>
