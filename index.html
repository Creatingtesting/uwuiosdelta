<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Lua/General Deobfuscator</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 18px; }
  textarea { width: 48%; height: 420px; font-family: monospace; font-size: 13px; }
  .col { display:inline-block; vertical-align:top; }
  .controls { margin: 8px 0 18px; }
  button { margin-right:6px; }
  label { display:inline-block; margin-right:10px; }
  input[type="text"] { width:200px; }
  .note { color:#666; font-size:13px; margin-top:8px; }
</style>
</head>
<body>
<h2>Lua / ASCII / Base64 / XOR Deobfuscator</h2>

<div class="controls">
  <button id="stripComments">Remove Comments</button>
  <button id="unescapeAscii">Unescape ASCII (\\123, \\x7b, \\u{...})</button>
  <button id="decodeBase64">Decode Base64</button>
  <label>XOR key: <input id="xorKey" type="text" placeholder="leave empty to brute-force 1-byte"/></label>
  <button id="xorDecode">XOR Decode</button>
  <button id="resolveVars">Resolve char variables & concatenation</button>
  <button id="expandLoadstring">Expand loadstring("...")</button>
  <button id="all">Run All</button>
  <button id="reset">Reset Output ‚Üê Input</button>
</div>

<div>
  <div class="col">
    <h3>Input</h3>
    <textarea id="input" spellcheck="false" placeholder="Paste obfuscated code here"></textarea>
  </div>
  <div class="col" style="margin-left:18px">
    <h3>Output</h3>
    <textarea id="output" spellcheck="false" placeholder="Deobfuscated output will appear here"></textarea>
  </div>
</div>

<div class="note">
  Notes: The tool uses heuristics. For XOR brute force it tries single-byte keys and shows outputs that look mostly printable. If you want a multi-byte key brute force, paste the key or request it. Use only on code you own or are permitted to analyze.
</div>

<script>
(function(){
  const inputEl = document.getElementById('input');
  const outputEl = document.getElementById('output');

  function setOutput(text){ outputEl.value = text; }
  function getText(){ return outputEl.value || inputEl.value; }

  // Remove Lua comments: -- single-line and --[[ ... ]]
  function stripComments(str){
    // Remove block comments --[[ ... ]]
    str = str.replace(/--\[\[[\s\S]*?\]\]/g, '');
    // Remove single-line comments -- ... (but preserve shebangs maybe)
    str = str.replace(/(^|[^:"'\\])--[^\r\n]*/g, function(m, p1){
      return p1;
    });
    return str;
  }

  // Unescape \ddd, \xhh, \u{hhhh}
  function unescapeAscii(str){
    // handle decimal escapes like \117
    str = str.replace(/\\([0-9]{1,3})/g, function(_, d){
      try { return String.fromCharCode(parseInt(d,10)); } catch(e) { return _; }
    });
    // hex escapes \xhh
    str = str.replace(/\\x([0-9A-Fa-f]{1,2})/g, function(_, h){
      return String.fromCharCode(parseInt(h,16));
    });
    // unicode \u{h...}
    str = str.replace(/\\u\{([0-9A-Fa-f]+)\}/g, function(_, h){
      return String.fromCodePoint(parseInt(h,16));
    });
    // common escaped quotes/backslashes
    str = str.replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/\\\\/g, '\\');
    return str;
  }

  // Detect base64-like tokens and decode them
  function decodeBase64Heuristic(str){
    // Replace patterns like "SGVsbG8=" or 'SGVsbG8=' or [[SGV..]]
    // We'll try to decode all base64-like substrings of length >= 8 and valid base64 chars
    const b64Regex = /(['"])([A-Za-z0-9+\/=]{8,})\1/g;
    return str.replace(b64Regex, function(_, quote, token){
      try {
        // check valid padding
        if(token.length % 4 !== 0) return _; 
        // decode using atob (browser)
        const decoded = atob(token);
        // If decoded has many non-printable characters, skip
        const printableRatio = decoded.split('').filter(c => {
          const code = c.charCodeAt(0);
          return (code >= 32 && code <= 126) || code===10 || code===13 || code===9;
        }).length / Math.max(1, decoded.length);
        if(printableRatio < 0.6) return _;
        // return quoted decoded content
        return quote + decoded + quote;
      } catch(e){
        return _;
      }
    });
  }

  // Replace "local v1 = 'p'" or local v1 = "\112" or local v1 = 112 or local v1 = 'a' or local v1 = "a"
  // Build mapping and replace concatenations like v1..v2..v3 or v1..'x' etc
  function resolveCharVariables(str){
    // 1) extract assignments
    const lines = str.split('\n');
    const mapping = {}; // varname -> string
    const assignRe = /^\s*(?:local\s+)?([A-Za-z_]\w*)\s*=\s*(.+?)\s*$/;
    for(let ln of lines){
      let m = ln.match(assignRe);
      if(!m) continue;
      const name = m[1];
      let rhs = m[2].trim();
      // strip trailing semicolon or comment
      rhs = rhs.replace(/;$/, '').replace(/--.*$/, '').trim();
      // string literal
      let s = null;
      let q = rhs.match(/^(['"])([\s\S]*)\1$/);
      if(q){
        s = q[2];
        s = unescapeAscii(s);
        mapping[name] = s;
        continue;
      }
      // numeric literal (ascii code)
      let n = rhs.match(/^([0-9]+)$/);
      if(n){
        mapping[name] = String.fromCharCode(parseInt(n[1],10));
        continue;
      }
      // decimal escape in quotes like '\112'
      let decesc = rhs.match(/^['"]((?:\\\d{1,3})+)['"]$/);
      if(decesc){
        mapping[name] = unescapeAscii(decesc[1]);
        continue;
      }
      // single identifier assigned to another var (chain)
      let id = rhs.match(/^([A-Za-z_]\w*)$/);
      if(id && mapping[id[1]] !== undefined){
        mapping[name] = mapping[id[1]];
        continue;
      }
    }

    // 2) replace concatenations: pattern like v1..v2..'a'..v3 => "p"+"r"+"a"+...
    // We'll replace occurrences of (\w+(?:\.\.\w+)+) and attempt to evaluate
    function evalConcat(match){
      // split by .., trim each part
      const parts = match.split(/\.\./).map(s=>s.trim());
      let out = '';
      for(const p of parts){
        // variable
        if(/^([A-Za-z_]\w*)$/.test(p)){
          if(mapping[p] !== undefined) out += mapping[p];
          else return match; // can't resolve
        } else {
          // string literal
          const q = p.match(/^(['"])([\s\S]*)\1$/);
          if(q) out += unescapeAscii(q[2]);
          else return match;
        }
      }
      return JSON.stringify(out); // return quoted string
    }

    // global replace: find concat groups of at least one '..'
    str = str.replace(/([A-Za-z_]\w*(?:\s*\.\.\s*(?:[A-Za-z_]\w*|['"][\s\S]*?['"]))+)/g, function(m){
      return evalConcat(m);
    });

    // last pass: replace single variable references with mapped char if safe (word boundaries)
    for(const k in mapping){
      const val = mapping[k];
      // only replace if mapped value is short (likely a char)
      if(val.length <= 8){
        // replace whole-word occurrences
        const re = new RegExp('\\b' + k + '\\b', 'g');
        str = str.replace(re, JSON.stringify(val));
      }
    }
    return str;
  }

  // XOR decode helper: supports numeric keys or string keys
  function xorDecodeWithKey(dataStr, keyStr){
    // dataStr: either raw bytes in JS string or something like "\123\12"
    const data = Array.from(dataStr).map(c => c.charCodeAt(0));
    const key = Array.from(keyStr).map(c => c.charCodeAt(0));
    if(key.length === 0) return null;
    const out = data.map((b,i) => String.fromCharCode(b ^ key[i % key.length])).join('');
    return out;
  }

  // Heuristic XOR: find quoted strings that look like binary-ish and try XOR
  function xorDecodeHeuristic(str, suppliedKey){
    // find quoted strings
    const qRegex = /(['"])([\s\S]{4,}?)\1/g;
    let changed = str;
    let any = false;
    changed = changed.replace(qRegex, function(_, quote, token){
      // attempt only if token has nonprintables or escaped pattern
      // convert escaped sequences first
      const raw = unescapeAscii(token);
      if(suppliedKey !== null){
        const dec = xorDecodeWithKey(raw, suppliedKey);
        if(isMostlyPrintable(dec)){
          any = true;
          return quote + dec + quote;
        } else {
          return _; // no change
        }
      } else {
        // brute-force single byte keys
        for(let k=1;k<256;k++){
          const key = String.fromCharCode(k);
          const candidate = xorDecodeWithKey(raw, key);
          if(isMostlyPrintable(candidate) && looksLikeCode(candidate)){
            any = true;
            return quote + candidate + quote;
          }
        }
        return _;
      }
    });
    return { out: changed, found: any };
  }

  function isMostlyPrintable(s){
    if(!s || s.length===0) return false;
    let printable = 0;
    for(let i=0;i<s.length;i++){
      const c = s.charCodeAt(i);
      if((c >= 32 && c <= 126) || c===9 || c===10 || c===13) printable++;
    }
    return printable / s.length > 0.8;
  }
  function looksLikeCode(s){
    // crude heuristic: contains keywords or semicolons or 'function' or 'local' or 'print' or '('
    return /function|local|print|loadstring|return|=|\(|\)|\{|\}|\;/.test(s);
  }

  // Expand loadstring("...") by decoding quoted inner content
  function expandLoadstring(str){
    // find loadstring("...") or load("...") patterns
    return str.replace(/(loadstring|load)\(\s*(['"])([\s\S]*?)\2\s*\)/g, function(_, fn, q, inner){
      // unescape inner then return fn(deobf) representation
      const decoded = unescapeAscii(inner);
      return fn + '(' + JSON.stringify(decoded) + ')';
    });
  }

  // Buttons
  document.getElementById('stripComments').addEventListener('click', function(){
    setOutput(stripComments(getText()));
  });
  document.getElementById('unescapeAscii').addEventListener('click', function(){
    setOutput(unescapeAscii(getText()));
  });
  document.getElementById('decodeBase64').addEventListener('click', function(){
    setOutput(decodeBase64Heuristic(getText()));
  });
  document.getElementById('resolveVars').addEventListener('click', function(){
    setOutput(resolveCharVariables(getText()));
  });
  document.getElementById('expandLoadstring').addEventListener('click', function(){
    setOutput(expandLoadstring(getText()));
  });
  document.getElementById('xorDecode').addEventListener('click', function(){
    const key = document.getElementById('xorKey').value;
    const suppliedKey = key === '' ? null : key;
    const res = xorDecodeHeuristic(getText(), suppliedKey);
    if(res.found) setOutput(res.out);
    else {
      alert('No plausible XOR decode found with given options. Try providing a key or allow brute-force (leave key empty).');
      setOutput(getText());
    }
  });
  document.getElementById('all').addEventListener('click', function(){
    let t = getText();
    t = stripComments(t);
    t = unescapeAscii(t);
    t = decodeBase64Heuristic(t);
    t = resolveCharVariables(t);
    t = expandLoadstring(t);
    // attempt XOR brute
    const xorTry = xorDecodeHeuristic(t, null);
    if(xorTry.found) t = xorTry.out;
    setOutput(t);
  });
  document.getElementById('reset').addEventListener('click', function(){
    setOutput(inputEl.value);
  });

  // initialize output with input
  inputEl.addEventListener('input', function(){
    outputEl.value = inputEl.value;
  });

  // Fill with sample for quick testing (comment out if you like)
  //inputEl.value = "local v1 = '\\112'\\nlocal v2 = '\\114'\\nlocal v3 = '\\105'\\nlocal v4 = '\\110'\\nlocal v5 = '\\116'\\nprint(v1..v2..v3..v4..v5)";
  //outputEl.value = inputEl.value;
})();
</script>
</body>
</html>
