<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoonSec V3 Lua Deobfuscator</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8fafc;
            color: #1f2937;
        }
        h1 {
            text-align: center;
            font-size: 2.5rem;
            color: #1e40af;
            margin-bottom: 1rem;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            padding: 1rem;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .input-section, .output-section {
            display: flex;
            flex-direction: column;
        }
        label {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #374151;
        }
        textarea {
            width: 100%;
            height: 400px;
            padding: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            resize: vertical;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            background: #f9fafb;
            transition: border-color 0.2s;
        }
        textarea:focus {
            outline: none;
            border-color: #1e40af;
            box-shadow: 0 0 0 3px rgba(30, 64, 175, 0.1);
        }
        button {
            background: linear-gradient(to right, #1e40af, #3b82f6);
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            margin-top: 1rem;
            transition: transform 0.2s, background 0.2s;
        }
        button:hover {
            background: linear-gradient(to right, #1e3a8a, #2563eb);
            transform: translateY(-2px);
        }
        #output {
            width: 100%;
            min-height: 400px;
            padding: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: #f9fafb;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            overflow-y: auto;
        }
        .error {
            color: #dc2626;
            font-size: 0.9rem;
            margin-top: 0.5rem;
            font-weight: 500;
        }
        .info {
            color: #4b5563;
            font-size: 0.9rem;
            margin-top: 0.5rem;
            line-height: 1.5;
            text-align: center;
        }
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
            textarea, #output {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <h1>MoonSec V3 Lua Deobfuscator</h1>
    <p class="info">
        Paste your obfuscated MoonSec V3 Lua code below and click "Deobfuscate". This tool uses every known method (ASCII, base64, XOR, hex, VM emulation, etc.) to decode strings, constants, and logic. Complex scripts may require manual analysis or tools like Prometheus Deobfuscator.
    </p>
    <div class="container">
        <div class="input-section">
            <label for="input">Obfuscated MoonSec V3 Code:</label>
            <textarea id="input" placeholder="Paste your obfuscated MoonSec V3 Lua code here..."></textarea>
            <button onclick="deobfuscate()">Deobfuscate</button>
        </div>
        <div class="output-section">
            <label for="output">Deobfuscated Code:</label>
            <div id="output">Deobfuscated code will appear here...</div>
            <div id="error" class="error"></div>
        </div>
    </div>

    <script>
        let stringTable = []; // Store string table globally
        let constantTable = []; // Store constant table globally

        function deobfuscate() {
            const input = document.getElementById('input').value;
            const outputDiv = document.getElementById('output');
            const errorDiv = document.getElementById('error');

            // Reset output and error
            outputDiv.textContent = '';
            errorDiv.textContent = '';

            try {
                // Step 1: Extract and decode string table
                stringTable = extractStringTable(input);
                if (!stringTable) {
                    throw new Error('Failed to extract string table. Ensure the code is valid MoonSec V3.');
                }

                // Step 2: Decode hexadecimal constants
                let code = decodeHexConstants(input);

                // Step 3: Decode environment manipulations
                code = decodeEnvironment(code);

                // Step 4: Decode bytecode with all methods
                code = decodeBytecode(code);

                // Step 5: Reconstruct constant table
                code = reconstructConstantTable(code);

                // Step 6: Simplify VM and control flow
                code = simplifyVM(code);

                // Step 7: Emulate VM instructions
                code = emulateVMInstructions(code);

                // Step 8: Remove junk code
                code = removeJunkCode(code);

                // Step 9: Deobfuscate control flow
                code = deobfuscateControlFlow(code);

                // Step 10: Fix syntax errors
                code = fixSyntax(code);

                // Step 11: Format for readability
                code = formatLuaCode(code);

                outputDiv.textContent = code || 'No output generated. The code may be too complex.';
            } catch (err) {
                errorDiv.textContent = `Error: ${err.message}`;
            }
        }

        function extractStringTable(code) {
            const stringTableMatch = code.match(/s\s*=\s*"([^"]*)"/);
            if (!stringTableMatch) return null;

            const encodedStr = stringTableMatch[1];
            const result = [];
            let i = 0;

            while (i < encodedStr.length) {
                if (encodedStr[i] === '\5') break;
                if (encodedStr[i] === '\2') {
                    // Decode ASCII string
                    const length = encodedStr.charCodeAt(i + 1);
                    const bytes = encodedStr.slice(i + 2, i + 2 + length);
                    let decoded;
                    try {
                        decoded = String.fromCharCode(...bytes.split('').map(c => c.charCodeAt(0)));
                    } catch {
                        decoded = `str_${bytes.replace(/[^a-zA-Z0-9]/g, '')}`;
                    }
                    result.push(decoded);
                    i += 2 + length;
                } else if (encodedStr[i] === '\3') {
                    // Boolean toggle
                    const length = encodedStr.charCodeAt(i + 1);
                    const decoded = encodedStr.slice(i + 2, i + 2 + length);
                    result.push(decoded !== '\0');
                    i += 2 + length;
                } else if (encodedStr[i] === '\6') {
                    // Function reference
                    const length = encodedStr.charCodeAt(i + 1);
                    const decoded = encodedStr.slice(i + 2, i + 2 + length);
                    result.push(`func_${decoded.replace(/[^a-zA-Z0-9]/g, '')}`);
                    i += 2 + length;
                } else if (encodedStr[i] === '\4') {
                    // Reference to another decoded value
                    const length = encodedStr.charCodeAt(i + 1);
                    const decoded = encodedStr.slice(i + 2, i + 2 + length);
                    result.push(`ref_${decoded.replace(/[^a-zA-Z0-9]/g, '')}`);
                    i += 2 + length;
                } else if (encodedStr[i] === '\0') {
                    // Table reference
                    const length = encodedStr.charCodeAt(i + 1);
                    const decoded = encodedStr.slice(i + 2, i + 2 + length);
                    result.push(`table_${decoded.replace(/[^a-zA-Z0-9]/g, '')}`);
                    i += 2 + length;
                } else {
                    i++;
                }
            }
            return result;
        }

        function decodeHexConstants(code) {
            // Convert hexadecimal constants (e.g., 0x29 to 41)
            return code.replace(/0x[0-9a-fA-F]+/g, match => parseInt(match, 16).toString());
        }

        function decodeEnvironment(code) {
            // Handle _ENV or getfenv manipulations
            code = code.replace(/getfenv\s*and\s*getfenv\(\)/g, '_G');
            code = code.replace(/r=(not\s*r)\s*and\s*_ENV\s*or\s*r;/g, 'r = _G;');
            code = code.replace(/_PxOySmLLeOLo/g, '_G');
            return code;
        }

        function decodeBytecode(code) {
            // Decode bytecode segments (e.g., d(238, "_qy90ziQwRZ5!StAqQ"))
            const bytecodeMatches = code.match(/d\(\d+,\s*"([^"]*)"\)/g) || [];
            for (const match of bytecodeMatches) {
                const [, encoded] = match.match(/d\(\d+,\s*"([^"]*)"\)/);
                let decoded = encoded;
                const decoders = [
                    // Base64
                    () => atob(encoded.replace(/[^A-Za-z0-9+/=]/g, '')),
                    // ASCII
                    () => String.fromCharCode(...encoded.split('').map(c => c.charCodeAt(0))),
                    // XOR with common keys (42, 69, 123)
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) ^ 42)).join(''),
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) ^ 69)).join(''),
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) ^ 123)).join(''),
                    // Shift ciphers (+1, -1)
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) - 1)).join(''),
                    () => encoded.split('').map(c => String.fromCharCode(c.charCodeAt(0) + 1)).join(''),
                    // Rot13
                    () => encoded.replace(/[a-zA-Z]/g, c => String.fromCharCode(
                        (c.charCodeAt(0) <= 90 ? 65 : 97) + ((c.charCodeAt(0) % 26) + 13) % 26
                    ))
                ];
                for (const decoder of decoders) {
                    try {
                        decoded = decoder();
                        if (decoded && /[\w\s(){};=]/.test(decoded)) break;
                    } catch {
                        continue;
                    }
                }
                code = code.replace(match, `"${decoded.replace(/"/g, '\\"')}"`);
            }

            // Replace string table references
            stringTable.forEach((item, index) => {
                const placeholder = `(ref_|table_|func_)${index}\\b`;
                code = code.replace(new RegExp(placeholder, 'g'), JSON.stringify(item));
            });

            return code;
        }

        function reconstructConstantTable(code) {
            // Extract and simplify constant table (e.g., c = {...})
            const constantTableMatch = code.match(/c\s*=\s*{([^}]*)}/);
            if (constantTableMatch) {
                let constants = constantTableMatch[1].split(',').map(s => s.trim()).filter(s => s);
                constants = constants.map((c, i) => `${c} -- const_${i}`);
                code = code.replace(constantTableMatch[0], `c = {\n  ${constants.join(',\n  ')}\n}`);
                constantTable = constants.map(c => c.split(' -- ')[0]);
            }
            return code;
        }

        function simplifyVM(code) {
            // Remove redundant VM loops and control flow
            code = code.replace(/while\s*n<\d+\s*do\s*n=n\+1;.*?end/g, '');
            code = code.replace(/e=\(e[*+-\d%]+\)\%\d+/g, '');
            code = code.replace(/if\s*e%2~=0\s*then\s*.*?else\s*.*?end/g, '');
            code = code.replace(/local\s*\w+\s*=\s*\d+;/g, '');
            code = code.replace(/n=n\+1;e=d\[n\];/g, '');
            return code;
        }

        function emulateVMInstructions(code) {
            // Map MoonSec VM opcodes to Lua operations
            const opcodeMap = {
                't\\[(\\d+)\\]=t\\[(\\d+)\\]\\[(\\d+)\\];': (match, r, l, s) => `t[${r}] = t[${l}][${s}];`, // Table index
                't\\[(\\d+)\\]=c\\[(\\d+)\\];': (match, r, l) => `t[${r}] = ${JSON.stringify(constantTable[l] || `const_${l}`)};`, // Constant load
                't\\[(\\d+)\\]\\[(\\d+)\\]=t\\[(\\d+)\\];': (match, r, l, s) => `t[${r}][${l}] = t[${s}];`, // Table set
                't\\[(\\d+)\\]=t\\[(\\d+)\\]\\(.*?\\);': (match, r, l) => `t[${r}] = t[${l}]();`, // Function call
                't\\[(\\d+)\\]=\\(t\\[(\\d+)\\](?:~=|==)[^;]+\\);': (match, r, l) => `t[${r}] = t[${l}];`, // Conditional assign
                'for\\s*e=(\\d+),(\\d+)\\s*do\\s*t\\[e\\]=nil;end': () => '', // Clear table range
                't\\[(\\d+)\\]={};': (match, r) => `t[${r}] = {};`, // Table creation
                't\\[(\\d+)\\]=\\d+;': (match, r) => `t[${r}] = number;`, // Numeric assign
                'local\\s*(\\w+)=\\(function\\([^)]*\\).*?end\\)\\(\\);': (match, var) => `local ${var} = deobfuscated_function;`, // Inline function
            };

            for (const [pattern, replacer] of Object.entries(opcodeMap)) {
                code = code.replace(new RegExp(pattern, 'g'), replacer);
            }

            // Replace constant references
            code = code.replace(/c\[(\d+)\]/g, (match, index) => {
                return JSON.stringify(constantTable[index] || stringTable[index] || `const_${index}`);
            });

            return code;
        }

        function deobfuscateControlFlow(code) {
            // Simplify flattened control flow
            code = code.replace(/if\s*\(t\[(\d+)\](?:~=|==)[^)]+\)\s*then\s*n=n\+1;else\s*n=(\d+);end/g, '');
            code = code.replace(/while\s*true\s*do\s*if\s*n<-\d+\s*then\s*n=n\+42\s*end\s*.*?end/g, '');
            return code;
        }

        function removeJunkCode(code) {
            // Remove junk assignments and dead code
            code = code.replace(/t\[\d+\]=0x[0-1];/g, '');
            code = code.replace(/local\s*\w+\s*=\s*\{[^}]*\};/g, '');
            code = code.replace(/;+/g, ';');
            code = code.replace(/local\s*\w+\s*=\s*function\s*\(\)\s*end;/g, '');
            return code;
        }

        function fixSyntax(code) {
            // Fix unbalanced parentheses
            let openParens = (code.match(/\(/g) || []).length;
            let closeParens = (code.match(/\)/g) || []).length;
            if (openParens > closeParens) {
                code += ')'.repeat(openParens - closeParens);
            } else if (closeParens > openParens) {
                code = code.slice(0, -(closeParens - openParens));
            }

            // Remove trailing commas in tables
            code = code.replace(/,\s*}/g, '}');
            // Fix double commas
            code = code.replace(/,,\s*/g, ',');
            // Fix double semicolons
            code = code.replace(/;+\s*/g, ';');
            // Remove redundant locals
            code = code.replace(/local\s*\w+\s*=\s*nil;/g, '');
            return code;
        }

        function formatLuaCode(code) {
            // Format Lua code for readability
            const lines = code.split('\n');
            let indentLevel = 0;
            const formatted = lines.map(line => {
                line = line.trim();
                if (!line) return '';
                if (line.match(/^end\b/)) indentLevel = Math.max(0, indentLevel - 1);
                const indent = '  '.repeat(indentLevel);
                if (line.match(/^(function|if|for|while)\b/)) indentLevel++;
                return indent + line;
            }).filter(line => line);
            return formatted.join('\n');
        }
    </script>
</body>
</html>
